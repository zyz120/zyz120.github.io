<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="四次元">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="四次元">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="名が無い生身">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>四次元</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">四次元</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">たましいホーム</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">名が無い生身</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/02/UE5_VFX_Learning_MagicBall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/02/UE5_VFX_Learning_MagicBall/" class="post-title-link" itemprop="url">NiagaraSystemでマジックボールを作る（学習メモ）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-05-02 02:31:04 / Modified: 22:58:26" itemprop="dateCreated datePublished" datetime="2024-05-02T02:31:04+09:00">2024-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BE%8E%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">美术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="NiagaraSystemでマジックボールを作る"><a href="#NiagaraSystemでマジックボールを作る" class="headerlink" title="NiagaraSystemでマジックボールを作る"></a>NiagaraSystemでマジックボールを作る</h1><p>　今日はUE5のNiagaraSystemを使って三つのマジックボールを作った。作る時のキーポイントを記録したいと思う。</p>
<hr>
<h3 id="「１」エレクトリックボール（Electric-Ball）"><a href="#「１」エレクトリックボール（Electric-Ball）" class="headerlink" title="「１」エレクトリックボール（Electric Ball）"></a>「１」エレクトリックボール（Electric Ball）</h3><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_02_47_47_621.gif" alt=""></p>
<p>　このボールは、主に二つのパーツで組み合わせて完成された。一つ目は、外のボールの殻で、二つ目は、中の雷の渦巻きである。
　</p>
<h4 id="ボールの殻を作る"><a href="#ボールの殻を作る" class="headerlink" title="ボールの殻を作る"></a>ボールの殻を作る</h4><p>　まず、マテリアルの基本設定をし、それは「BlendMode」を「Translucent」にすることと「ShadingMode」を「Unlit」にすることだ。<br>　殻の外部が色を付けられ、内部が透明にするため、「VertexNormalWS」と「CameraVector」をドット積で計算する。それで、カメラに向いているほど、計算結果が「1」に近い。そして「OneMinus」で、内部が「0」に近い、その数字を透明度にすると、望みの効果が出来る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502030226.png" alt=""></p>
<p>　そして、殻が周りの風景を映すため、一つのCubeMapを使った。そのCubeMapをサンプリングするため、Node「Reflection Vector」を使った。そのノードは、カメラから表面までの射線を反射したベクターだ。<br>　最後に、二つのパーツを組み合わせて完成する。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502030734.png" alt=""></p>
<h4 id="雷の渦巻きを作る"><a href="#雷の渦巻きを作る" class="headerlink" title="雷の渦巻きを作る"></a>雷の渦巻きを作る</h4><p>　<br>　まず、デフォルトのUVの原点は左上なので、渦巻きを作るため、[UV.xy-(.5, .5)]*nの計算をする。その結果は以下である。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502031638.png" alt=""></p>
<p>　そして、転換したUVを、「VectorToRadialValue」を使って、極座標に転換する。その極座標を使って、ちょっと乱雑なテキスチャーをサンプリングすると、渦巻っぽいの交換が出る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_03_21_18_522.gif" alt=""></p>
<p>　この効果を基にし、透明度とパーティクルカーラーを設定すると完了だ。</p>
<h4 id="NiagaraSystemで組み合わせ"><a href="#NiagaraSystemで組み合わせ" class="headerlink" title="NiagaraSystemで組み合わせ"></a>NiagaraSystemで組み合わせ</h4><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502032408.png" alt=""></p>
<p>　ここで注意すべきのポイントはいくつある。<br>　まず、このボールをマップの中で自由に移動するため、これらのEmitterで「Local Space」をチェックする（でないと、一つのパーティクルのライフタイムが終わるまでずっと同じ場所にいる）。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502202800.png" alt=""></p>
<p>　次は、色を調整する時、HSVの「V」は明度であり、その数値を上げるほど、色の「強さ」も上がる。その「強さ」は、PostEffectでのBloom効果を調整する時に役に立つ。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502202830.png" alt=""></p>
<hr>
<h3 id="「２」火球（ファイアボール）"><a href="#「２」火球（ファイアボール）" class="headerlink" title="「２」火球（ファイアボール）"></a>「２」火球（ファイアボール）</h3><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_03_26_25_69.gif" alt=""></p>
<p>　この火球の効果は主に三つのパーツの組み合わせで完成された。一つ目は真ん中の火炎の球体で、二つ目は球体の後ろにうっすりと点滅している放射線状な効果で、三つ目は周囲にある渦巻のような効果である。</p>
<h4 id="火炎の球体"><a href="#火炎の球体" class="headerlink" title="火炎の球体"></a>火炎の球体</h4><p>　<br>　火炎の球体は球体のMesh＋マテリアルで完成する。MaterialのShaderの基本設定は下図のようにする。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502210434.png" alt=""></p>
<p>　今回はBlendModeをTranslucentやAdditiveではなく、Maskedに設定するのは、「透明度」の数字を調整する必要がないからだ（「見える(1)」と「見えない(0)」だけで十分）。設定完了すると、Material Graphに以下のように、二つの煙のテキスチャーをサンプリングして乗算すると、効果が出る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_21_13_55_309.gif" alt=""></p>
<p>　その灰色の球体を「OpacityMask」に設定し、基本設定の「Opacity Mask Clip Value」を調整し、火球が見える。</p>
<p>　そして、球体を着色する時、「Two Sided Sign」というノードを使った。このノードはMeshの表と裏のサーフェイス（triangle）に対するアウトプットは違い、表は「1」、裏は「-1」をアウトプットする。これを用いて火球の全体を完成する。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502212056.png" alt=""></p>
<h4 id="放射線状の効果"><a href="#放射線状の効果" class="headerlink" title="放射線状の効果"></a>放射線状の効果</h4><p>　SpriteのUVを調整するだけで、この効果が実現できる。<br>　<br>　<img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502222052.png" alt=""></p>
<p>　上図のように、まずUVから（.5, .5）のバーテックス（Vertex）を引き（原点が真ん中にし）、そしてNormalizeと、原点から同じ方向のすべてのポイントは同じ数値を持っている。この数値で任意模様のテキスチャーをサンプリングすると、放射線みたいな効果が出る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_22_25_21_478.gif" alt=""></p>
<h4 id="渦巻"><a href="#渦巻" class="headerlink" title="渦巻"></a>渦巻</h4><p>　一番目のエレクトリックボールの渦巻きに類似するので、上の文章を参考してください。</p>
<hr>
<h3 id="「３」波のボール"><a href="#「３」波のボール" class="headerlink" title="「３」波のボール"></a>「３」波のボール</h3><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_22_27_56_443.gif" alt=""></p>
<p>　このボールは主に上記の二つのボールで使われたパーツの組み合わせで完成できる。しかし、緑色のリングの部分は少し記録しなければならないものがある。</p>
<hr>
<h4 id="緑色のリング"><a href="#緑色のリング" class="headerlink" title="緑色のリング"></a>緑色のリング</h4><p>　まずは、リングを作る。「RadialGradientExponential」ノードにCosine計算を加えると、リングのような効果が出る。この結果に、Powerで計算すると、より細いリングが出来る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502224000.png" alt=""></p>
<p>　そして、UVにテキスチャーでNoiseを加えると、リングが歪んでる感じができる。ここのトリックは、一つの「Dynamic Parameter」を使って、その「歪み」の程度をコントロールする。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502224433.png" alt=""><br>　<br>　そうすると、Niagara Systemでこのパラメータを操作することができる。下図のようにカーブを設定し、ライフタイムの最後に歪みながら消える効果が出る。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502224651.png" alt=""></p>
<hr>
<h3 id="ディストーション（Distortion）効果を作る"><a href="#ディストーション（Distortion）効果を作る" class="headerlink" title="ディストーション（Distortion）効果を作る"></a>ディストーション（Distortion）効果を作る</h3><p>　以上三つのボールの共通点は、バックグラウンドにはディストーション（Distortion）の効果がある。その効果をじつげんするため、Refractionを使う。下図のように基本設定をする。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502225245.png" alt=""></p>
<p>　しかし、デフォルトで「Refraction」のチェックは不可能の状態であり、基本設定で「Refraction Method」を設定しなければならない。ここは「Noramlを使う」にした。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20240502225450.png" alt=""></p>
<p>　そして下図のようにグラフを繋ぐと完成する。グラフの一番下の「Dynamic Parameter」を使った原因は、Niagara Systemでこのマテリアルを使う時、ディストーションの強さを調整しやすくしたいからだ。</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/录制_2024_05_02_22_55_44_199.gif" alt=""></p>
<hr>
<p>　以上で全てのボールの紹介が完了した～</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/02/IntensifyShooting_DevelopLog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/02/IntensifyShooting_DevelopLog/" class="post-title-link" itemprop="url">Intensity Shootingの開発記録</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-02 14:50:02" itemprop="dateCreated datePublished" datetime="2022-11-02T14:50:02+09:00">2022-11-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-11-13 23:49:31" itemprop="dateModified" datetime="2022-11-13T23:49:31+09:00">2022-11-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Intensity-Shootingの開発記録（The-Develop-Log）"><a href="#Intensity-Shootingの開発記録（The-Develop-Log）" class="headerlink" title="　Intensity Shootingの開発記録（The Develop Log）"></a>　Intensity Shootingの開発記録（The Develop Log）</h1><p>　以前からローグライクゲームが好きで、今回は自分でローグライクのシューティングゲームを開発したいと思って、この文章を開発過程として記録する。<br>　Unity2021を用いて、ゼロから作り方と問題を記録し、以降何かの問題がある時参考になったら幸運だと思う。</p>
<hr>
<h3 id="2022-11-02"><a href="#2022-11-02" class="headerlink" title="　2022/11/02"></a>　2022/11/02</h3><p>　最新の機能を使用するため、URPのレンダーパイプラインを選択した。<br>　<br>　2Dゲームだから、私はTileを使ってゲームマップを作ると決めた。まずはアセットストアで無料の素材をダウンロードし、<strong>TilePattle</strong>を作成する。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111152726.png" alt=""><br>　<strong>Rectangular Tilemap</strong>をクリエートし、マップを作成する。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111153014.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111152902.png" alt=""><br>　Tilemapのコライダーは、TilemapCollider2Dを使って形成することで、最初はTileAssetずつコライダーが分離されているが、<strong>「Used By Composite」をオンにして、CompositeCollider2Dを添付する</strong>と、一つのコライダーになることが可能だ。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111154750.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111154812.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111154818.png" alt=""><br>　マップの背景は四つのレイヤーで作られたもので、<strong>カメラにスクリプトを付け</strong>、カメラの動きと共に、レイヤー１つずつ移動する距離が違い、シーンのパースペクティブな感じを作る。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec2.gif" alt=""></p>
<center><font size=2 color=#AAAAAA>[パースペクティブなシーン]</font></center>

<hr>
<h3 id="2022-11-03"><a href="#2022-11-03" class="headerlink" title="　2022/11/03"></a>　2022/11/03</h3><p>　今日は主人公の絵を描く予定だ。<br>　アセットストアでダウンロードしたアセットは主に<strong>ピクセルスタイル</strong>だから、主人公も同じスタイルで描かれると考える。そのため、私はAsepriteを使って完成した。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111160435.png" alt=""><br>　主人公の基本的な感じが決まった後、<strong>idleとrunningの動画キーフレーム</strong>を完成した。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111160627.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111160749.png" alt=""><br>　その上、シューティングゲームだから、主人公の武器として、少し<strong>ハイテク感</strong>のある銃を描いた。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111161038.png" alt=""><br>　そしてUnityに導入し、Animatorに整理した。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111161205.png" alt=""></p>
<hr>
<h3 id="2022-11-04"><a href="#2022-11-04" class="headerlink" title="2022/11/04"></a>2022/11/04</h3><p>　今日は主人公の<strong>移動とジャンプ</strong>をコントロールするスクリプトを開発する。<br>　まずは移動で、単にプレーヤーの押しているボタンをチェックし、移動方向を決め、現在のポジションに相応の<strong>距離を加える</strong>だけだ。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void UpdateMove()</span><br><span class="line">&#123;</span><br><span class="line">    int moveDir = GetMoveDir();</span><br><span class="line"></span><br><span class="line">    this.transform.localPosition += new Vector3(moveDir * Time.deltaTime * this.MoveSpeed, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　次はジャンプで、一つ目のステップは<strong>毎フレームでプレーヤーが地面にいるかどうかをチェックし</strong>、状態をアップデートする。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111171936.png" alt=""><br>　そして、CanJump()というファンクションを使って、主人公がジャンプできるかどうかを確認する。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111172140.png" alt=""><br>　最後、RigidBody2Dにフォースをあげて、ジャンプさせる。ちなみに、DoJump()のはじめる所に、<strong>小さなY軸の距離を与える</strong>のは、その次のフレームに、上のCanJump()にチェックされないようにするから。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111172553.png" alt=""></p>
<hr>
<h3 id="2022-11-05"><a href="#2022-11-05" class="headerlink" title="2022/11/05"></a>2022/11/05</h3><p>　今日は<strong>銃の動画とカメラのマウスにフォローする効果</strong>を作った。<br>　まず、銃の動画は、銃の角度をマウスの位置によって変化することである。これは、マウスの位置と銃の位置を引き算し、ベクトルのYとXを<strong>逆三角関数のTanを使い、角度を計算すること</strong>により、実現する。ちなみに、その角度はラジアンだから、<strong>πで加算しないで、そのまま使うと、違う結果が出る</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double angle_PI = Math.Atan2((double)deltaPos.y , Mathf.Abs(deltaPos.x));</span><br><span class="line">float angle_Rate = (float)angle_PI / (2 * Mathf.PI) * 360.0f;</span><br><span class="line">this.transform.localRotation = Quaternion.Euler(0, 0, angle_Rate);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec3.gif" alt=""></p>
<p>　次は、カメラがマウスの位置にフォローする効果を作る。これは、プレーヤーの<strong>視野を広げ、より良い体験を与える</strong>ため作った機能である。<br>　実現する方法はたくさんあるから、ここは表示しないで、直接に結果を展示する。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec4.gif" alt=""></p>
<hr>
<h3 id="2022-11-06"><a href="#2022-11-06" class="headerlink" title="2022/11/06"></a>2022/11/06</h3><p>　今日は銃の発砲する機能を作った。<br>　「発砲」という行為を<strong>面白くする</strong>ため、弾丸が壁にぶつかる時、小さな<strong>光とパーティクルシステム</strong>を加えた。その上、今後の武器を強化する可能性を開くため、弾丸が壁にぶつかる時<strong>跳ね返る</strong>機能も追加する。<br>　次は実際の効果である。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec5.gif" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title="　"></a>　</h2><h3 id="2022-11-07"><a href="#2022-11-07" class="headerlink" title="2022/11/07"></a>2022/11/07</h3><p>　今日は敵の怪物と主人公の攻撃される効果を作った。<br>　攻撃が命中することを表現するため、攻撃させる対象のSpriteにブリンクの効果を与える。これを実現するため、私は<strong>URPのSprite Lit Shader Graph</strong>を使った。一つのシェーダーグラフに<strong>ブリンク（Blink）とディゾルブ（Dissolve）</strong>の効果が実現させる。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221111181846.png" alt=""><br>　そして、怪物にHPを計算するスクリプトを付け、HPが0になったら<strong>死亡する</strong>。怪物が死亡する時、上記のディゾルブ効果を使う。<br>　以下は全部の効果である。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec6.gif" alt=""></p>
<hr>
<h3 id="2022-11-09"><a href="#2022-11-09" class="headerlink" title="2022/11/09"></a>2022/11/09</h3><p>　今日は怪物の攻撃を作った。<br>　私は戦闘の時、<strong>賑やかな</strong>場面を作りたいため、怪物の攻撃が<strong>環境に影響を与える</strong>ようにデザインした。それは、「血の流れ」という感じで敵のブレットを作った。<br>　まずは、<strong>血の滝</strong>を作る。私はパーティクルシステムを利用し、以下のようなテキスチャーを使ってランダムな角度を付けて作った。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221113183533.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec7.gif" alt=""><br>　次は、血の滝が地面に痕跡を残すようにする。私は<strong>スクリプトでOnParticleCollisionのファッション</strong>を使用し、血が地面にぶつかる所に新しい血のSpriteを<strong>インスタンス化</strong>する。そのファンクションを使うため、パーティクルシステムにCollisionの<strong>「Send Collision Messages」</strong>をオンにすることが必要である。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221113185103.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221113185500.png" alt=""><br>　そして、新しい血のSpriteに<strong>Mask Interactionを「Visible Inside Mask」をチェック</strong>し、マップにMaskを付け、以下のような効果ができた。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec8.gif" alt=""></p>
<hr>
<h3 id="2022-11-11"><a href="#2022-11-11" class="headerlink" title="2022/11/11"></a>2022/11/11</h3><p>　今日は前の日に作った怪物の<strong>攻撃能力を具体的な怪物に与えた</strong>。<br>　例として、幾つの怪物を地面に置いておき、それぞれの怪物に<strong>スクリプトでAIを付け</strong>、プレーヤーを攻撃するようになる。<br>　そして、プレーヤーが攻撃を受ける時、HPの減少を表現するため、私は簡易な<strong>UI</strong>を作った。ここまで、ゲームの<strong>基本的な循環</strong>ができた。<br>　効果が以下のように。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Rec9.gif" alt=""></p>
<hr>
<h3 id="2022-11-13"><a href="#2022-11-13" class="headerlink" title="2022/11/13"></a>2022/11/13</h3><p>　今日はVFXを使って二つ目の攻撃効果を作った。<br>　VFXを使うため、<strong>VFXをインストールする</strong>必要がある。まずは<strong>Package Managerに「Visual Effect Graph」をインポート</strong>し、そして<strong>PreferencesのVisual Effect</strong>に<strong>Experimental Operators/Blocksをチャック</strong>する。それにより、実験的な方法が使えるようになる。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221113192135.png" alt=""><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20221113192152.png" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/13/Soft_Max_Function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/13/Soft_Max_Function/" class="post-title-link" itemprop="url">Hexoで個人サイトを搭載する方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-13 23:17:52" itemprop="dateCreated datePublished" datetime="2022-09-13T23:17:52+09:00">2022-09-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-14 01:06:12" itemprop="dateModified" datetime="2022-09-14T01:06:12+09:00">2022-09-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hexoで個人サイトを構築する方法"><a href="#Hexoで個人サイトを構築する方法" class="headerlink" title="　Hexoで個人サイトを構築する方法"></a>　Hexoで個人サイトを構築する方法</h1><p>　最近、新しいパソコンを買った。ブログをアップロードしたくて、もう一度ブログ環境を構築しなければならない。今度このような時に作成方法を忘れないようになる為、ここで構築ステップを記録しておく。</p>
<h2 id=""><a href="#" class="headerlink" title="　"></a>　</h2><h2 id="Hexoとは"><a href="#Hexoとは" class="headerlink" title="Hexoとは"></a>Hexoとは</h2><p>　Hexoとは、Node.jsというプログラム言語で駆動し、静的サイトを構築するプログラムの一種である。</p>
<hr>
<h2 id="Hexoでサイトを構築するステップ"><a href="#Hexoでサイトを構築するステップ" class="headerlink" title="Hexoでサイトを構築するステップ"></a>Hexoでサイトを構築するステップ</h2><h4 id="Gitをインストール"><a href="#Gitをインストール" class="headerlink" title="Gitをインストール"></a>Gitをインストール</h4><p>　まず、<a target="_blank" rel="noopener" href="https://git-scm.com/download/win">Gitの公式サイト</a>から、Gitをダウンロードしておく。<br>　ダウンロードしてインストールした後、任意のフォルダーの空白スペースに右クリックすると、このようなメニューが見えるはずだ。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914004335.png" alt=""><br>　続いて、Git Bashで以下のように自分のGithubのユーザー名とメールアドレスのコンフィグを設定し、ssh秘密鍵を生成する。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Github User Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;Github User EmailAddress&quot;</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;Github User EmailAddress&quot;</span></span><br></pre></td></tr></table></figure><br>　そして、生成した秘密鍵ファイルをオープンして、その内容を全てコピーし、<a target="_blank" rel="noopener" href="https://github.com/settings/keys">Github Setting Keys</a>に移動してペーストする（Title任意）。<br>　完成後、Git Bashで次の命令を入力し、以下の画面と同じ結果が出たら、成功と見なす。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@github.com</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914005556.png" alt=""></p>
<hr>
<h4 id="Node-jsをインストール"><a href="#Node-jsをインストール" class="headerlink" title="Node.jsをインストール"></a>Node.jsをインストール</h4><p>　Gitをインストールした後、Node.jsのインストールも必要である。<br>　Node.jsの<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">公式サイト</a>でダウンロードし、インストールしておく。<br>　自分でそのインストールが成功するか否かをチェックすることができる。Cmdの中で次の命令を入力して、バージョニングが出てくると、成功とする。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914010046.png" alt=""></p>
<hr>
<h4 id="Hexoをインストール"><a href="#Hexoをインストール" class="headerlink" title="Hexoをインストール"></a>Hexoをインストール</h4><p>　最後は、Hexo自体のインストールである。<br>　Cmdの中で、次のnpm命令でHexoをダウンロードとインストールする。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>　少し時間がかかる場合もあるので、安心に待ってください。</p>
<hr>
<h4 id="終わり"><a href="#終わり" class="headerlink" title="終わり"></a>終わり</h4><p>　以上のステップ全部終わったら、ブログ環境が全て構築完了である。<br>　これからまた楽しくブログを書こう。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/13/Hexo_Site_Make_Method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/13/Hexo_Site_Make_Method/" class="post-title-link" itemprop="url">Hexoで個人サイトを搭載する方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-13 23:17:52" itemprop="dateCreated datePublished" datetime="2022-09-13T23:17:52+09:00">2022-09-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-14 01:06:12" itemprop="dateModified" datetime="2022-09-14T01:06:12+09:00">2022-09-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hexoで個人サイトを構築する方法"><a href="#Hexoで個人サイトを構築する方法" class="headerlink" title="　Hexoで個人サイトを構築する方法"></a>　Hexoで個人サイトを構築する方法</h1><p>　最近、新しいパソコンを買った。ブログをアップロードしたくて、もう一度ブログ環境を構築しなければならない。今度このような時に作成方法を忘れないようになる為、ここで構築ステップを記録しておく。</p>
<h2 id=""><a href="#" class="headerlink" title="　"></a>　</h2><h2 id="Hexoとは"><a href="#Hexoとは" class="headerlink" title="Hexoとは"></a>Hexoとは</h2><p>　Hexoとは、Node.jsというプログラム言語で駆動し、静的サイトを構築するプログラムの一種である。</p>
<hr>
<h2 id="Hexoでサイトを構築するステップ"><a href="#Hexoでサイトを構築するステップ" class="headerlink" title="Hexoでサイトを構築するステップ"></a>Hexoでサイトを構築するステップ</h2><h4 id="Gitをインストール"><a href="#Gitをインストール" class="headerlink" title="Gitをインストール"></a>Gitをインストール</h4><p>　まず、<a target="_blank" rel="noopener" href="https://git-scm.com/download/win">Gitの公式サイト</a>から、Gitをダウンロードしておく。<br>　ダウンロードしてインストールした後、任意のフォルダーの空白スペースに右クリックすると、このようなメニューが見えるはずだ。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914004335.png" alt=""><br>　続いて、Git Bashで以下のように自分のGithubのユーザー名とメールアドレスのコンフィグを設定し、ssh秘密鍵を生成する。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Github User Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;Github User EmailAddress&quot;</span></span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;Github User EmailAddress&quot;</span></span><br></pre></td></tr></table></figure><br>　そして、生成した秘密鍵ファイルをオープンして、その内容を全てコピーし、<a target="_blank" rel="noopener" href="https://github.com/settings/keys">Github Setting Keys</a>に移動してペーストする（Title任意）。<br>　完成後、Git Bashで次の命令を入力し、以下の画面と同じ結果が出たら、成功と見なす。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@github.com</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914005556.png" alt=""></p>
<hr>
<h4 id="Node-jsをインストール"><a href="#Node-jsをインストール" class="headerlink" title="Node.jsをインストール"></a>Node.jsをインストール</h4><p>　Gitをインストールした後、Node.jsのインストールも必要である。<br>　Node.jsの<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">公式サイト</a>でダウンロードし、インストールしておく。<br>　自分でそのインストールが成功するか否かをチェックすることができる。Cmdの中で次の命令を入力して、バージョニングが出てくると、成功とする。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220914010046.png" alt=""></p>
<hr>
<h4 id="Hexoをインストール"><a href="#Hexoをインストール" class="headerlink" title="Hexoをインストール"></a>Hexoをインストール</h4><p>　最後は、Hexo自体のインストールである。<br>　Cmdの中で、次のnpm命令でHexoをダウンロードとインストールする。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>　少し時間がかかる場合もあるので、安心に待ってください。</p>
<hr>
<h4 id="終わり"><a href="#終わり" class="headerlink" title="終わり"></a>終わり</h4><p>　以上のステップ全部終わったら、ブログ環境が全て構築完了である。<br>　これからまた楽しくブログを書こう。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/Lens_Language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/22/Lens_Language/" class="post-title-link" itemprop="url">レンズの言語</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-22 15:28:24" itemprop="dateCreated datePublished" datetime="2022-01-22T15:28:24+09:00">2022-01-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-14 01:06:27" itemprop="dateModified" datetime="2022-09-14T01:06:27+09:00">2022-09-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">心理学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="レンズの言語（The-Language-of-the-Lens）"><a href="#レンズの言語（The-Language-of-the-Lens）" class="headerlink" title="　レンズの言語（The Language of the Lens）"></a>　レンズの言語（The Language of the Lens）</h1><p>　映像は絵と同じく、作者が見ることや感じること、または思想を注いで創作した作品である。変化しない画像と違って、映像にはもう一つの軸、いわゆる<strong>時間軸</strong>がある。その時間という軸をうまく使ったら、画像より多くの情報や効果を表現することが可能になる。今日検討したい内容は、<strong>映像あるいはゲーム</strong>などの作品の中、視点を移動する時に使われるトリック、つまり、「レンズの言語」ということだ。<br>　レンズの言語とは、レンズそのものが<strong>言葉</strong>のように撮影者の<strong>意図を伝達する</strong>ことである。撮影する時の<strong>角度や構図、被写界深度や焦点距離</strong>により、観客が受ける感覚も大きく異なっている。それはまるで作者本人が直接に言葉で観客に作品について解説しているようだ。<br>　私は次の幾つかの方面で「レンズの言語」を具体的に紹介する。</p>
<hr>
<h2 id="レンズとの距離（ショット）"><a href="#レンズとの距離（ショット）" class="headerlink" title="　レンズとの距離（ショット）"></a>　レンズとの距離（ショット）</h2><h3 id="ロングショット"><a href="#ロングショット" class="headerlink" title="　ロングショット"></a>　ロングショット</h3><p>　ロングショットとはカメラと被写体の<strong>距離が長い</strong>状態で撮影する画面である。人間の場合、人を頭から足まで映ることが多くて、人間以外なら、ストーリーが発生した環境を映ることが多い。それは主に<strong>全体的に人間関係とストーリーの舞台</strong>を紹介するためだ。例えば、サマータイムレンダのエンディングに主人公がいる島の全体像が映られている。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220913183613.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[サマータイムレンダのエンディング]</font></center>

<hr>
<h3 id="ミディアムショット"><a href="#ミディアムショット" class="headerlink" title="　ミディアムショット"></a>　ミディアムショット</h3><p>　ミディアムショットはロングショットとクローズショットの真ん中で、中間的な感じがあり、普通は人の腰または胸から頭までの部分（半身像）が映られている。それは画面の中の人数により、違い意味がある。<br>　同一の画面に複数な人がいれば、彼らの動作と関係を表す場合が多くて、一人しかいない場合は、その人の動作と表情を強調することが一般的に考えられている。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220913184815.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[东京ゴッドファーザーズ]</font></center>

<hr>
<h3 id="クローズショット・クローズアップ"><a href="#クローズショット・クローズアップ" class="headerlink" title="クローズショット・クローズアップ"></a>クローズショット・クローズアップ</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/22/%E5%8D%92%E5%88%B6Video/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/22/%E5%8D%92%E5%88%B6Video/" class="post-title-link" itemprop="url">レンズの言語</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-22 15:28:24" itemprop="dateCreated datePublished" datetime="2022-01-22T15:28:24+09:00">2022-01-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-14 01:06:27" itemprop="dateModified" datetime="2022-09-14T01:06:27+09:00">2022-09-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">心理学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="レンズの言語（The-Language-of-the-Lens）"><a href="#レンズの言語（The-Language-of-the-Lens）" class="headerlink" title="　レンズの言語（The Language of the Lens）"></a>　レンズの言語（The Language of the Lens）</h1><p>　映像は絵と同じく、作者が見ることや感じること、または思想を注いで創作した作品である。変化しない画像と違って、映像にはもう一つの軸、いわゆる<strong>時間軸</strong>がある。その時間という軸をうまく使ったら、画像より多くの情報や効果を表現することが可能になる。今日検討したい内容は、<strong>映像あるいはゲーム</strong>などの作品の中、視点を移動する時に使われるトリック、つまり、「レンズの言語」ということだ。<br>　レンズの言語とは、レンズそのものが<strong>言葉</strong>のように撮影者の<strong>意図を伝達する</strong>ことである。撮影する時の<strong>角度や構図、被写界深度や焦点距離</strong>により、観客が受ける感覚も大きく異なっている。それはまるで作者本人が直接に言葉で観客に作品について解説しているようだ。<br>　私は次の幾つかの方面で「レンズの言語」を具体的に紹介する。</p>
<hr>
<h2 id="レンズとの距離（ショット）"><a href="#レンズとの距離（ショット）" class="headerlink" title="　レンズとの距離（ショット）"></a>　レンズとの距離（ショット）</h2><h3 id="ロングショット"><a href="#ロングショット" class="headerlink" title="　ロングショット"></a>　ロングショット</h3><p>　ロングショットとはカメラと被写体の<strong>距離が長い</strong>状態で撮影する画面である。人間の場合、人を頭から足まで映ることが多くて、人間以外なら、ストーリーが発生した環境を映ることが多い。それは主に<strong>全体的に人間関係とストーリーの舞台</strong>を紹介するためだ。例えば、サマータイムレンダのエンディングに主人公がいる島の全体像が映られている。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220913183613.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[サマータイムレンダのエンディング]</font></center>

<hr>
<h3 id="ミディアムショット"><a href="#ミディアムショット" class="headerlink" title="　ミディアムショット"></a>　ミディアムショット</h3><p>　ミディアムショットはロングショットとクローズショットの真ん中で、中間的な感じがあり、普通は人の腰または胸から頭までの部分（半身像）が映られている。それは画面の中の人数により、違い意味がある。<br>　同一の画面に複数な人がいれば、彼らの動作と関係を表す場合が多くて、一人しかいない場合は、その人の動作と表情を強調することが一般的に考えられている。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20220913184815.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[东京ゴッドファーザーズ]</font></center>

<hr>
<h3 id="クローズショット・クローズアップ"><a href="#クローズショット・クローズアップ" class="headerlink" title="クローズショット・クローズアップ"></a>クローズショット・クローズアップ</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/14/FurRendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/14/FurRendering/" class="post-title-link" itemprop="url">毛发渲染（Fur Rendering）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-14 13:23:05" itemprop="dateCreated datePublished" datetime="2021-11-14T13:23:05+09:00">2021-11-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-15 20:06:59" itemprop="dateModified" datetime="2021-11-15T20:06:59+09:00">2021-11-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="毛发渲染（Fur-Rendering）"><a href="#毛发渲染（Fur-Rendering）" class="headerlink" title="毛发渲染（Fur Rendering）"></a>毛发渲染（Fur Rendering）</h1><p>在<strong>实时渲染</strong>中，毛发的渲染可以看作一个单独的课题，毛发因为其数量多的原因，如果为每根毛发单独建模或渲染，会给CPU和GPU都带来很大的压力。因此，我们采用一些tricks，让毛发<strong>看起来是真实的</strong>，并且在实时渲染中可以接受的性能消耗之内来完成。<br>由于毛发渲染的方法有很多，这篇文章介绍的是<strong>多pass方式的毛发渲染</strong>，又叫做<strong>shell-based rendering</strong>。参考自<a target="_blank" rel="noopener" href="https://xbdev.net/directx3dx/specialX/Fur/index.php">&#x1F4CC;bkenwright@xbdev.net的教程</a>。</p>
<h2 id="毛发的特征"><a href="#毛发的特征" class="headerlink" title="毛发的特征"></a>毛发的特征</h2><p><strong>1、毛发数量众多、质地柔软</strong><br>毛发由数量众多的细小圆柱体组成，并且毛发通常是柔软的，互相交叉重叠在一起。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114160228.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[互相交叠的柔软毛发]</font></center>

<p><strong>2、毛发自身互相产生阴影</strong><br>毛发自身产生的阴影会投射到其他的毛发之上，由于毛发基本都是<strong>从根部到尖端由粗到细</strong>，因此越接近毛发的根部，阴影越强。在实时渲染中我们不会精确计算到毛发自身的投影，但是可以利用<strong>靠近根部的阴影强</strong>这一点来做一个模拟的AO。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114161427.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[越靠近根部阴影越强]</font></center>

<p><strong>3、毛发边缘透光、且颜色越淡透光越强</strong><br>在<strong>背光</strong>时，可以明显看出毛发的<strong>边缘部分</strong>能够<strong>透过一部分光线</strong>，并且毛发的<strong>颜色越浅，透光越强</strong>。在摄影中，逆光拍摄的时候可以明显看出这种现象。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114162049.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[头发的边缘透光现象]</font></center>

<p><strong>4、毛发的各向异性高光</strong><br>与一般物体不同，毛发的<strong>表面有许多凸起、凹痕等</strong>，这让毛发并没有一个明显区域的高光，与之相反，毛发的高光更偏向各个方向均有一部分。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114162929.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[显微镜下的毛发 + 高光]</font></center>

<p><strong>但是</strong><br>好在我们在<strong>实时渲染</strong>中可以效果较好、代价较低地模拟上述的毛发特征。这里引用《3D数学基础：图形与游戏开发（3D Math Primer For Graphics And Game Development）》中的“图形学第一定律”——</p>
<p><strong>如果它看上去是对的，那么它就是对的（If it <em>looks</em> right, it <em>is</em> right）</strong>。</p>
<hr>
<h2 id="毛发的渲染过程"><a href="#毛发的渲染过程" class="headerlink" title="毛发的渲染过程"></a>毛发的渲染过程</h2><h3 id="多Pass渲染"><a href="#多Pass渲染" class="headerlink" title="多Pass渲染"></a>多Pass渲染</h3><p>本文中我们采用<strong>多pass渲染</strong>的方式来渲染毛发，即用多个pass，每个pass渲染<strong>一层</strong>，让多层叠加在一起产生毛发的效果。在每一层中，我们均将<strong>顶点</strong>沿<strong>法线方向挤出</strong>一小段距离，这样在多个pass的执行下，我们便得到了<strong>大量的层</strong>，每一层都是上一层沿法线方向的放大。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114174850.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[沿法线挤出的多层示意]</font></center>

<p>通常，我们沿法线挤出后，所形成的新的层仍然是<strong>一个整体</strong>（即如果我们把一个平面挤出一次后，所得到的层仍然是一个平面），那按理说我们得到的仅仅是重叠在一起的多个层，并非是毛发。为了让这些层看起来像毛发，我们可以使用<strong>沃里噪声（Worley Noise）贴图</strong>，每层对其进行采样，<strong>采样值作为alpha逐层递减</strong>，由于沃里噪声形状的特性，我们便可以在每个pass中得到一系列逐层变细的面片，当<strong>层数足够多</strong>时，看上去就和毛发一样。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114180747.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[沃里噪声]</font></center>

<p>以下是多pass渲染的一段简单结构示意：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line">	Tags &#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span> &#125;</span><br><span class="line">	Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">	</span><br><span class="line">	Pass</span><br><span class="line">	&#123;</span><br><span class="line">		CGPROGRAM</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">		</span><br><span class="line">		v2f <span class="built_in">vert</span>(a2v v) &#123; <span class="keyword">return</span> <span class="built_in">Vert_fur</span>(v, FUR_OFFSET); &#125;</span><br><span class="line">		<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_Target &#123;</span> <span class="keyword">return</span> <span class="built_in">Frag_fur</span>(i); &#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;	</span><br><span class="line">	Pass &#123;...&#125;	</span><br><span class="line">	Pass &#123;...&#125;	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中的<strong>FUR_OFFSET</strong>为层高，即我们每层挤出的距离，FUR_OFFSET的间隔越大，毛发越长，但是每一层的区别也看得更明显，更容易穿帮。因此<strong>总层数与层高</strong>需要在效果与性能之间通过调试来做取舍。</p>
<hr>
<h3 id="第一步：法线挤出与噪声采样"><a href="#第一步：法线挤出与噪声采样" class="headerlink" title="第一步：法线挤出与噪声采样"></a>第一步：法线挤出与噪声采样</h3><p>具体原理在上述<strong>多pass渲染</strong>节已经说明完毕，我们按照其方法来做毛发渲染的第一步——<strong>法线挤出和噪声采样</strong>。<br>首先，在<strong>顶点着色器</strong>中，我们将<strong>每个顶点沿法线挤出</strong>，并计算<strong>主纹理和沃里噪声的tilling和offset</strong>，代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v.vertex.xyz += v.normal * FUR_OFFSET * _FurLength;</span><br><span class="line"></span><br><span class="line">o.uv.xy = v.uv * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = v.uv * _NoiseTex_ST.xy + _NoiseTex_ST.zw;</span><br></pre></td></tr></table></figure><br>在<strong>片元着色器</strong>中，我们<strong>采样沃里噪声</strong>，并根据FUR_OFFSET的值来让alpha逐层缩小，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> alphaOrigin = <span class="built_in">tex2D</span>(_NoiseTex, i.uv.zw).r;</span><br><span class="line"><span class="keyword">float</span> alpha = <span class="built_in">clamp</span>(alphaOrigin - FUR_OFFSET, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经得到了沿法线挤出的多层，并且沃里噪声采样的alpha值逐层递减，目前我们得到的“毛发”效果如下：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114184158.png" alt=""></p>
<p>可见效果非常不尽如人意，中间部分几乎看不清，考虑到开头提到的<strong>毛发特征第二点</strong>，我们先来为其加上AO。</p>
<hr>
<h3 id="第二步：毛发的自投影（AO）"><a href="#第二步：毛发的自投影（AO）" class="headerlink" title="第二步：毛发的自投影（AO）"></a>第二步：毛发的自投影（AO）</h3><p>因为我们<strong>每一层（每一pass）</strong>均有一个FUR_OFFSET变量，所以我们想计算AO会变得非常方便。试想，毛发越接近根部，其阴影越强，因此我们只需要让根部的光线作用效果减弱即可，而FUR_OFFSET又恰好是从根部到尖端<strong>由小到大</strong>，我们便可以轻松计算如下。<br>在<strong>顶点着色器中</strong>，我们增加了<strong>__AO参数</strong>，用来调整阴影效果，其代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half ao = <span class="built_in">pow</span>(FUR_OFFSET, _AO) + <span class="number">0.04</span>;</span><br></pre></td></tr></table></figure><br>我们将结果传入<strong>片段着色器</strong>，并用结果乘以该值如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result *= aoVal;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们用<strong>模拟的AO</strong>给毛发加入了自投影，得到的“毛发”效果如下：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211114185242.png" alt=""></p>
<p>可见仅通过简单的AO计算，我们已经能够将<strong>毛发的阴影</strong>效果表现出来了，但是可以发现，我们的毛发现在均沿着法线向外，看起来像“刺猬”，并不符合<strong>毛发的特征一</strong>，即并不柔软，因此我们接下来需要让毛发变得更加柔软。</p>
<hr>
<h3 id="第三步：得到柔软的毛发"><a href="#第三步：得到柔软的毛发" class="headerlink" title="第三步：得到柔软的毛发"></a>第三步：得到柔软的毛发</h3><p>为了让我们的毛发看起来不像“刺猬”，我们需要让毛发<strong>变软</strong>，这里我们通过<strong>UV偏移</strong>的方式来实现这一效果。<br>我们根据FUR_OFFSET，来对<strong>采样沃里噪声时的UV</strong>进行逐层偏移，相当于我们每一层采样时都相比上一层进行了一小段偏移，这样最终我们得到的毛发就会是弯曲的，也就达到了我们想要的<strong>柔软</strong>的效果。<br>为了方便调整效果，我定义了向量<strong>__UVOffset</strong>变量，其xy分量来对UV进行偏移，其z分量用来调整FUR_OFFSET带来的影响，公式如下：<br>$uvOffset = UVOffset.xy · FUROFFSET^{UVOffset.z} $<br>于是，我们在<strong>顶点着色器</strong>中，有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float2 uvOffset = _UVOffset.xy * <span class="built_in">pow</span>(FUR_OFFSET, _UVOffset.z) * <span class="number">0.1</span>;</span><br><span class="line">o.uv.zw = v.uv * _NoiseTex_ST.xy + _NoiseTex_ST.zw + uvOffset;  </span><br></pre></td></tr></table></figure>
<p>至此，我们给毛发加入了UV偏移，得到了<strong>逐层弯曲</strong>的毛发，并且能够通过一个变量调整效果，结果如下：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/Fur_3.gif" alt=""></p>
<p>目前，我们已经得到了毛发的<strong>几何形态</strong>，接下来，我们需要让光照对我们的毛发产生影响，以此来实现开头提到的<strong>毛发特征3~4</strong>，在光照上，首先我们从最经典最基础的<strong>漫反射</strong>开始。</p>
<hr>
<h3 id="第四步：光照——漫反射"><a href="#第四步：光照——漫反射" class="headerlink" title="第四步：光照——漫反射"></a>第四步：光照——漫反射</h3><p>漫反射仍然采用经典的<strong>Lambert算法</strong>，用<strong>法线和入射光方向的点乘</strong>作为漫反射的结果，这里我们对结果加上一个变量<strong>LightFilter</strong>，用来调整光的穿透程度，代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> NdotL = <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line"><span class="keyword">float</span> diff = <span class="built_in">saturate</span>(NdotL + LightFilter);</span><br></pre></td></tr></table></figure><br>事实上，当我们将上述结果直接用作漫反射结果时，得到的效果是很差的，因为其破坏了<strong>毛发尖端阴影更少，亮度更强</strong>的原则。<br>因此，这里我们正好可以利用FUR_OFFSET变量来改善这一结果，因为NdotL的<strong>结果范围是(-1, 1)</strong>，所以我们加上<strong>范围为(0, 1)的FUR_OFFSET</strong>后，就得到了<strong>范围在(0, 2)的结果</strong>，我们用saturate来将结果限制在(0, 1)即可得到优化后的结果。代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> NdotL = <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line"><span class="keyword">float</span> diff = <span class="built_in">saturate</span>(NdotL + LightFilter + FUR_OFFSET);</span><br></pre></td></tr></table></figure><br>最终我们能够得到如下的结果（图中分别对比了加与不加FUR_OFFSET的效果），注意，这里展示的效果仅仅是将<strong>diff的数值可视化</strong>：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115011055.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[ 无FUR_OFFSET vs 加入FUR_OFFSET ]</font></center>

<p>在有了漫反射后，我们已经完成了光照的第一步，接下来我们来完成开篇所说的<strong>毛发特征第三点</strong>，这可以让毛发边缘能够透过一部分光线从而显得<strong>亮度更高</strong>。</p>
<hr>
<h3 id="第五步：光照——边缘透光"><a href="#第五步：光照——边缘透光" class="headerlink" title="第五步：光照——边缘透光"></a>第五步：光照——边缘透光</h3><p>为了使边缘能够透光，即让光线只影响物体边缘，那么自然想到的就是<strong>菲涅尔反射</strong>。关于菲涅尔反射的计算公式有很多，这里我使用了下面的公式：<br>$Fresnal = max(0, min(1, (FresScale) + (1 - FresScale) · (1 - dot(ViewDir, normal)^{FresPower}  )))$<br>这里可以根据效果多尝试几种方法，都是没问题的。<br>在代码实现时，我们引入两个变量<strong><strong>FresnelScale和</strong>FresnelPower</strong>来帮助我们调整效果，具体实现如下，在<strong>顶点着色器</strong>中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half fresnel = <span class="number">1</span> - _FresnelScale + _FresnelScale * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldNormal, worldView), _FresnelPower);</span><br><span class="line">fresnel = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(<span class="number">1</span>, fresnel));</span><br></pre></td></tr></table></figure><br>在<strong>片元着色器</strong>中，我将结果加上了AO和FUR_OFFSET的影响，可以让边缘部分的亮度稍高一些，此外，还加入了<strong>__FresnelColor</strong>来调整透光部分的颜色，具体如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> fresnelVal = i.extraParam.w + aoVal * FUR_OFFSET * <span class="number">0.1</span>;</span><br><span class="line">result += fresnelVal * _FresnelColor;</span><br></pre></td></tr></table></figure><br>最终我们得到的结果如下，左右分别是有无AO和FUR_OFFSET的区别，注意，这里的效果仅仅是将<strong>fresnel值可视化</strong>的结果：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115145622.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[ 无AO/FUR_OFFSET vs 加入AO/FUR_OFFSET ]</font></center>

<p>拥有边缘光之后，我们已经完成了开头介绍的<strong>毛发特征三</strong>，接下来我们来完成最后的<strong>特征四</strong>，即<strong>各向异性高光</strong>。</p>
<hr>
<h3 id="第六步：光照——各向异性高光"><a href="#第六步：光照——各向异性高光" class="headerlink" title="第六步：光照——各向异性高光"></a>第六步：光照——各向异性高光</h3><p>与一般的高光不同，我们在计算<strong>毛发类</strong>的高光时采用<strong>各向异性高光</strong>，Blinn-Phong高光模型中我们使用了<strong>法线</strong>与向量H进行点乘计算（注：向量H指<strong>视角方向与入射光方向的中间向量</strong>），而在各向异性高光计算的时候，我们采用<strong>切线方向来代替法线</strong>进行计算，如下图<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115182050.png" alt=""><br>不难想象，对于圆柱体而言，其切线方向是不变的，均沿着毛发生长方向。值得一提的是，在图形学中，不同于<strong>唯一的法线</strong>，切线一般是由<strong>物体的UV方向</strong>来定义的，因此有些引擎中我们用来计算各向异性高光时不一定使用切线，而也有可能使用<strong>副切线</strong>进行计算，其中副切线可以由<strong>法线与切线的叉乘</strong>来求得。<br>有了我们所需要的数据之后，我们便可以将数据代入公式计算，这里我使用的是<strong>Kajiya-kay模型</strong>，其公式如下<br>$StrandSpecular = (\sqrt{1 - dot(Tangent, H)^2})^{exponent}$<br>其中<br>$H = normalize(ViewDir + LightDir)$<br>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">StrandSpec</span><span class="params">(float3 T, float3 L, float3 V, <span class="keyword">float</span> exponet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float3 H = <span class="built_in">normalize</span>(L + V);</span><br><span class="line">    <span class="keyword">float</span> TdotH = <span class="built_in">dot</span>(T, H);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="built_in">sqrt</span>(<span class="number">1</span> - TdotH * TdotH), exponet);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将<strong>高光计算结果可视化</strong>，便能够得到如下的结果，这一结果就是模拟了动漫中常见的<strong>头发</strong>上的<strong>天使环高光</strong>：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115183319.png" alt=""><br>注意，为了<strong>性能考虑</strong>，我们在毛发渲染的所有光照计算均在<strong>顶点着色器</strong>中完成，因此我们能在高光上看到明显的<strong>几何形状</strong>，并且毛发根部也被完整照亮了，这不是我们想要的效果，因此我们对该高光结果<strong>乘以FUR_OFFSET</strong>来弱化毛发根部的亮度，除此之外，我还加入了<strong>__StrandParam</strong>参数来方便调整高光效果，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	_StrandParam (<span class="string">&quot;高光参数：X-环区域，Y-高光亮度&quot;</span>, Vector) = (<span class="number">25.0</span>, <span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half strandSpec = <span class="built_in">StrandSpec</span>(worldBiTan, worldLight, worldView, _StrandParam.x) * FUR_OFFSET * _StrandParam.y;</span><br></pre></td></tr></table></figure>
<p>最终我们得到了如下结果（左图是我用<strong>Blinn-Phong高光模型</strong>的计算结果，可以明显看出其与<strong>各向异性高光</strong>的差别）：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115184104.png" alt=""></p>
<center><font size=2 color=#AAAAAA>[BlinnPhong vs 各向异性 ]</font></center>

<hr>
<h3 id="第七步——合并所有效果"><a href="#第七步——合并所有效果" class="headerlink" title="第七步——合并所有效果"></a>第七步——合并所有效果</h3><p>最后，我们把上面的效果全部合并，得到最终的毛发渲染结果。</p>
<p>首先，我们对纹理采样，获得物体<strong>固有色</strong>，并对得到的<strong>固有色与毛发颜色进行插值</strong>，得到一个基础的着色。<br>然后我们在该着色的基础上，加入漫反射与高光反射的影响，并且这里的<strong>高光</strong>我乘上了<strong>漫反射</strong>的结果，这是为了不让背光处出现天使环高光。<br>在上述光照的基础上，我们再加上<strong>边缘光</strong>，并且这里我为边缘光设定了一个可选颜色，让该颜色影响边缘光颜色。<br>最后，我们把结果乘以AO值，来加入<strong>自投影</strong>带来的阴影。<br>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采样+插值</span></span><br><span class="line">fixed3 baseCol = <span class="built_in">tex2D</span>(_MainTex, i.uv.xy).rgb;</span><br><span class="line">baseCol = <span class="built_in">lerp</span>(baseCol, _BaseColor, FUR_OFFSET * FUR_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 光照</span></span><br><span class="line">fixed3 result = (diff + diff * strandSpec) * baseCol * _LightColor0.rgb;</span><br><span class="line">result += fresnelVal * _FresnelColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AO</span></span><br><span class="line">result *= aoVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fixed4</span>(result.rgb, alpha);</span><br></pre></td></tr></table></figure>
<p>在将所有的计算结果合并后，我们就能得到毛发渲染的最终效果。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211115190407.png" alt=""></p>
<p>至此，我们完成了<strong>多pass方式的毛发渲染</strong>，但是该结果仍然有许多需要调整和优化的地方，譬如<strong>不同物体间毛发的穿插</strong>、<strong>毛发的动态</strong>等。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/10/GamePsycho/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/10/GamePsycho/" class="post-title-link" itemprop="url">Game Design & Psychology</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-10 15:11:50" itemprop="dateCreated datePublished" datetime="2021-11-10T15:11:50+09:00">2021-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-12 01:25:27" itemprop="dateModified" datetime="2021-11-12T01:25:27+09:00">2021-11-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">心理学</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="游戏设计与心理学（Game-Design-amp-Psychology）"><a href="#游戏设计与心理学（Game-Design-amp-Psychology）" class="headerlink" title="游戏设计与心理学（Game Design &amp; Psychology）"></a>游戏设计与心理学（Game Design &amp; Psychology）</h1><p>这篇文章将会记录一些我在学习过程中了解到的<strong>心理学相关知识</strong>，这些知识大部分应用在<strong>游戏设计</strong>中，所以这篇取标题为游戏心理学。<br>记录在此的理论、实验等，大多为<strong>游戏设计</strong>以及<strong>玩家行为</strong>背后包含的心理学知识，它们或是影响着我们的心情、或是驱动着我们的行为，甚至影响了我们在<strong>游戏之外</strong>的日常生活。我将以小标题的形式简要地记录每一种心理行为。</p>
<hr>
<h2 id="功能固着（Functional-Fixedness）"><a href="#功能固着（Functional-Fixedness）" class="headerlink" title="功能固着（Functional Fixedness）"></a>功能固着（Functional Fixedness）</h2><p>德国心理学家<strong>卡尔·邓克尔（Karl Duncker）</strong>提出了术语<strong>功能固着（Functional Fixedness）</strong>，其指的是：当人们看到物品的一种<strong>常用</strong>的功能或关联后，就很难看出它的其它用途；如果初次接触时看到的<strong>功能越重要</strong>，就<strong>越难</strong>看出其它用途。<br>如下图是邓克尔的蜡烛问题：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110163601.png" alt=""><br>即提供一板火柴，一个蜡烛，和一堆装在盒子里的图钉，要求修复墙上的烛台。这个问题的难点在于图钉一开始被装在盒子里，让人们固定地认为盒子的作用是装图钉而非作为烛台。</p>
<p>在游戏设计中，设计者往往会在给玩家提供<strong>新的道具</strong>的时候给与该道具的使用说明，除了设计者提供的方法之外，当玩家自己发现了游戏本身提供之外的<strong>新的使用方法</strong>时，往往会充满<strong>成就感</strong>并认为这是<strong>有趣的</strong>。如塞尔达传说荒野之息中的道具：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110165243.png" alt=""><br>当玩家初次获得道具时，得知的使用方法是<strong>让物体停止</strong>，但是随着游戏进度的深入，玩家自己能够挖掘出许多<strong>被告知</strong>之外的功能。</p>
<p>除了对玩家之外，<strong>游戏设计者</strong>也能挑出功能固着来产生不同的作品，如<strong>《Dandara》</strong>不同于一般的2D平台跳跃类游戏，将<strong>方向键和A键作为移动和跳跃</strong>，而是作为调整方向与重力的手段。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110165912.png" alt=""><br>《Dandara》的开发者最初是面向<strong>移动平台</strong>设计的游戏，这与面向<strong>PC或主机</strong>开发时的视角不同，但是他们发掘了<strong>手柄</strong>这一工具的不同使用方式，这告诉我们<strong>初始视角的不同</strong>有助于跳出功能固着心理。<br>意料之外的东西总是有趣的。</p>
<hr>
<h2 id="《蔚蓝（Celeste）》的镜之神庙如何创造“恐惧”"><a href="#《蔚蓝（Celeste）》的镜之神庙如何创造“恐惧”" class="headerlink" title="《蔚蓝（Celeste）》的镜之神庙如何创造“恐惧”"></a>《蔚蓝（Celeste）》的镜之神庙如何创造“恐惧”</h2><p>《蔚蓝》是一款出色的2D平台跳跃类游戏，在其硬核的游戏难度之外，开发者对于<strong>“恐惧”与“危险”</strong>这一要素的暗示也做得非常值得我们学习，尤其是第五章镜之神庙（Mirror Temple）。</p>
<p><strong>1、镜子与危险的联系</strong><br>主角的朋友被关在了<strong>镜子</strong>里，而在此前的关卡中，主角从镜子中看到了自己心中的梦魇，镜子这一意向已经被暗示了<strong>危险</strong>。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110172553.png" alt=""></p>
<p><strong>2、蜡烛颜色的暗示</strong><br>在章节开始的时候，玩家需要经过如下图的场景，在这一场景中，玩家见到了被关在镜子中的好友，而<strong>镜子预示着危险</strong>，镜子边上的两盏<strong>橙色蜡烛</strong>便自然能够让玩家将橙色与危险联系起来。此外，玩家通过移动来点亮蓝色的蜡烛并找到通往下一场景的路径，也自然地将<strong>蓝色</strong>与<strong>安全</strong>联系在一起。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110172948.png" alt=""><br>在之后的场景中，蜡烛与对应<strong>安全与危险</strong>的联系仍然会不断地被暗示和强调<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110173937.png" alt=""></p>
<p><strong>3、环境的暗示</strong><br>在关卡的进行过程中，周围环境也时刻给予玩家<strong>危险在附近</strong>的暗示，在该作中玩家没有攻击的手段，因此<strong>逃跑（Flee）</strong>变成了玩家的唯一选择。在该章节中，玩家<strong>只能看到自身周围的小范围区域</strong>，在玩家通过不同场景的过程中，黑暗中出现的各类怪异雕塑就成了<strong>危险就在身边</strong>的暗示源。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211110190938.png" alt=""></p>
<hr>
<h2 id="“停顿”的力量——首因-amp-近因效应（Primacy-amp-Recency-Effect）"><a href="#“停顿”的力量——首因-amp-近因效应（Primacy-amp-Recency-Effect）" class="headerlink" title="“停顿”的力量——首因&amp;近因效应（Primacy&amp;Recency Effect）"></a>“停顿”的力量——首因&amp;近因效应（Primacy&amp;Recency Effect）</h2><p>在2007年的一项实验中，受试者被关在一个<strong>完全黑暗</strong>的房间中48小时，在经过一天左右受试者出现了或多或少的幻觉，声称能够<strong>看见本不存在的东西</strong>。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111172952.png" alt=""></p>
<p>游戏也能够提供类似的环境。<br>游戏给我们的感官刺激主要来源于<strong>视觉和听觉</strong>，绝大部分时间我们都能够清晰地看到或听到游戏作品给玩家带来的感官刺激，但是在例如<strong>BOSS战、章节末、情感叙事</strong>等时候，常常会遇到<strong>渐渐消失的BGM、简单甚至全黑的场景</strong>等处理方式。这样的<strong>“停顿”处理</strong>和上述实验一样，除了让玩家能够<strong>“休息”</strong>一下之外，也给了让大脑自动补全这一段留白的环境，如<strong>回忆之前的冒险、为即将到来的危险做准备</strong>之类。下图分别为《铲子骑士（Shovel Knight）》、《任天堂全民星大乱斗（Super Smash Bros）》、《塞尔达传说：梅祖拉的假面（The Legend of Zelda: Majora’s Mask）》、《洛克人（Megaman）》中，运用<strong>“停顿”手法</strong>的场景举例。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111182047.png" alt=""></p>
<p>除了上述原因，让玩家能留下深刻印象的另一个原因，便是<strong>首因、近因效应（Primacy&amp;Recency Effect）</strong>。<br>让人们在听完一系列顺序出现的单词后，重新尽可能多地复述出现过的单词时，在<strong>首位以及末尾</strong>出现的单词，被成功复述的几率是最高的，这便是首因、近因效应。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111183342.png" alt=""></p>
<p>即<strong>最先出现和最新出现</strong>的事物，能在人们大脑中停留的时间更久，可以理解为这分别是长期记忆和短期记忆的体现。如在教育界，将一堂课拆分为多个小章节、比从头到尾一次性说完效果要好。在游戏设计上，每一次简短的“停顿”，能让玩家对这次停顿附近的<strong>游戏内容印象更深刻</strong>（如一次激动人心的BOSS战）。<br>对于游戏设计者来说，这带给我们的<strong>启发</strong>是，我们需要<strong>合理安排阶段性的内容</strong>，与全程都是高潮的作品相比，<strong>有张有弛的作品将能够在玩家心中留下更多的内容</strong>。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111185633.png" alt=""></p>
<p>如上图，每一次<strong>波峰</strong>都应当是玩家<strong>振奋人心的游戏体验</strong>，而每次一<strong>波谷</strong>都应当留给玩家的大脑来填充内容，正如先前的实验所说，当什么都不存在时，大脑会自动想象出不存在的事物。<br>利用<strong>“停顿”</strong>带来的<strong>首因、近因效应</strong>，能让设计者把想让玩家记住的东西更多地停留在玩家的记忆中。</p>
<hr>
<h2 id="被注视的力量（Power-of-being-watched）"><a href="#被注视的力量（Power-of-being-watched）" class="headerlink" title="被注视的力量（Power of being watched）"></a>被注视的力量（Power of being watched）</h2><p>在电子游戏中，“眼睛”常常被当作<strong>危险</strong>的信号，在极大多数有<strong>眼睛</strong>或者<strong>被注视感</strong>的场合中，往往会给人们带来恐惧、紧张的感觉。当设计者在暗示场景中潜伏着危险，或是在进行某些敌人形象的设计时，眼睛常常会成为一个重要参考，并且通常<strong>眼睛</strong>也会成为敌人的<strong>弱点</strong>之一，如下图。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111221746.png" alt=""></p>
<p>人类学家克洛德·列维·斯特劳斯（Claude Levi-Strauss）认为，人们对<strong>面具、小丑</strong>等感到<strong>恐惧</strong>的原因是它阻断了人与人之间的表情交流。当人们<strong>被注视</strong>的时候，在来源不明的眼睛形象上无法推测出对方的意图，这会触发人们的自我保护，倾向性地认为对方的意图是对自己<strong>有害的</strong>。<br>如下图，面具让我们无法根据面具后面的人的表情等判断其意图，让人们产生恐惧的感觉。当然，其中也包括由面具形象带来的<strong>恐怖谷（Uncanny Valley）</strong>效应，我打算把这一点放在另一篇恐怖相关的作品分析中讲述。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111224041.png" alt=""></p>
<p>除了被<strong>不明意图</strong>的注视，还有另一种被注视的方式，即<strong>观众</strong>。James Geer的《恐惧调查表》中显示了人们除了死亡、未知、危险动物等之外，<strong>社交、演讲、出丑</strong>等行为也在其列。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111233003.png" alt=""></p>
<p>人们发现，<strong>观众</strong>的存在会影响一个人的表现，譬如在别人的注视下完成一项工作的时候，有些人会表现出<strong>不愿意</strong>等<strong>负面</strong>情绪，并且其完成质量、效率等都会明显下降。对应到电子游戏中，如<strong>周围NPC的反馈、团队竞技中队友的关注、线下观众的围观</strong>等，会明显地影响玩家的思考能力以及发挥水准。但同时，也有一部分人在拥有观众的时候，会表现得比平时<strong>更出色</strong>。<br>通常，在人们<strong>水平不足</strong>时，注视会让他们<strong>发挥失常</strong>；而在<strong>水平较高</strong>时，注视能让他们<strong>更加出色</strong>。譬如，<strong>《宝可梦剑盾》</strong>中的道馆设计，周围观众的气氛能让玩家感觉自己的发挥比平时更加出色。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211111235119.png" alt=""></p>
<p>由此<strong>对设计者的启发</strong>是，当我们需要让玩家感到<strong>紧张焦虑</strong>时，我们可以在游戏<strong>初期</strong>，玩家<strong>技巧不成熟</strong>时加入<strong>观众</strong>；当我们需要让玩家感到<strong>自信、火热</strong>时，我们可以在玩家技巧已经<strong>成熟后</strong>加入<strong>观众</strong>；当我们需要营造<strong>恐惧、不适、危险</strong>等氛围时，我们可以加入<strong>视线来源不明</strong>的注视。</p>
<hr>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>TODO</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/02/RayMarching-BasicLighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/02/RayMarching-BasicLighting/" class="post-title-link" itemprop="url">RayMarching+BasicLighting</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-11-02 14:46:42" itemprop="dateCreated datePublished" datetime="2021-11-02T14:46:42+09:00">2021-11-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-14 14:27:30" itemprop="dateModified" datetime="2021-11-14T14:27:30+09:00">2021-11-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Ray-Marching-amp-Basic-Lighting"><a href="#Ray-Marching-amp-Basic-Lighting" class="headerlink" title="Ray Marching &amp; Basic Lighting"></a>Ray Marching &amp; Basic Lighting</h1><p>最近去学习了一下Ray marching相关的知识，虽然仅仅是一个入门。于是我准备将raymarching和基础的光照模型放在一篇文章里学习记录一下。</p>
<hr>
<h2 id="Ray-Marching（光线步进）"><a href="#Ray-Marching（光线步进）" class="headerlink" title="Ray Marching（光线步进）"></a>Ray Marching（光线步进）</h2><h3 id="Ray-Marching概念"><a href="#Ray-Marching概念" class="headerlink" title="Ray Marching概念"></a>Ray Marching概念</h3><p>先从Ray marching开始讲起，从名字可以看出，raymarching是一个<strong>模拟光线不断前进</strong>的过程。<br>我们想象从观察点（人眼或者相机）开始，对视线范围内的每一个方向都发射一条<strong>射线（Ray）</strong>，那么这条射线如果与某样物体相交，则这个方向上我们需要绘制这个物体，最终当我们对每条射线都这样检查完毕时，所有相交点都绘制完毕了（对于计算机来说，这里的“每条射线”就变成了从相机到屏幕每个像素的方向射线）。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102150236.png" alt=""></p>
<hr>
<h3 id="判断相交"><a href="#判断相交" class="headerlink" title="判断相交"></a>判断相交</h3><p>显然，这里我们会遇到一个问题，就是如何判断射线是否与某样物体相交。在raymarching中，我们采用<strong>找最短距离步进</strong>的方式来计算，即，对于一个物体，我们每次<strong>沿射线步进的距离</strong>是从<strong>该点到该物体的最短距离</strong>，这样我们就保证了，在这个步进半径内的任何一个点，都不会出现在该物体的内部。当我们某一次寻找该距离的值<strong>小于阈值</strong>时，我们就判断这个射线方向与物体<strong>相交</strong>，当总距离<strong>大于最大阈值</strong>时，我们判断这条射线方向没有物体。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102150907.png" alt=""><br>大体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">RayMarching</span><span class="params">(float3 rayOrigin, float3 rayDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> total = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ITERATION; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(total &gt; MAX_DISTANCE)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">		float3 pos = rayOrigin + rayDir * total;</span><br><span class="line">		<span class="keyword">float</span> distance = <span class="built_in">GetDistance</span>(pos);</span><br><span class="line">		</span><br><span class="line">		total += distance;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(distance &lt; MIN_DISTANCE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> total;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们会遇到第二个问题，就是代码中的GetDistance函数，我们如何知道某一点到某物体的最短距离呢，这里需要用到<strong>有符号距离场（Signed Distance Field, SDF）</strong>来计算。</p>
<hr>
<h3 id="有符号距离场（SDF）"><a href="#有符号距离场（SDF）" class="headerlink" title="有符号距离场（SDF）"></a>有符号距离场（SDF）</h3><p>有符号距离场可以看做一个<strong>对空间的表达函数</strong>，我们用一个方式来表达离某一点最近的空间距离（一般是一个<strong>标量场函数</strong>或一张<strong>立体纹理</strong>）。似乎SDF可以用来做AO（环境光遮蔽）和软阴影（Soft Shadow），如UE4，但是目前没有学习到，留个（TODO）。<br>在raymarching中，我们使用<strong>标量场函数</strong>来计算某点到物体的最短距离，这里拿最简单的球体来举例。我们有$Param_{Sphere}  = (x, y, z, w)$，这里记作S，其xyz分量为球心坐标，w分量为球的半径，又有$位置P(x,y,z)$，显然，从位置P到球S的最短距离为$\sqrt{(P.x - S.x)^2 + (P.y - S.y)^2 + (P.z - S.z)^2} - w$。<br>所以我们可以得到球体的标量场函数如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SDF_Sphere</span><span class="params">(float3 pos, float4 param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">length</span>(pos - param.xyz) - param.w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了球体，还有许多不同的标量场函数，如锥体、长方体、甜甜圈等，具体可以看<a target="_blank" rel="noopener" href="https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">&#x1F4CC;InigoQuilez大佬的文章</a></p>
<hr>
<h3 id="SDF的其它计算"><a href="#SDF的其它计算" class="headerlink" title="SDF的其它计算"></a>SDF的其它计算</h3><p>上述标量场函数仅仅是单个几何体的表达，通过对不同标量场的计算，我们可以得到<strong>多个几何体</strong>的<strong>布尔运算结果</strong>，如交集、差集、并集等。<br>这里仍然以最简单的交集为例，我们只需要将两个SDF函数的结果求得最小值即可，代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Operation_Union</span><span class="params">(<span class="keyword">float</span> sdf1, <span class="keyword">float</span> sdf2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(sdf1, sdf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，还有一些复杂的计算如平滑过渡的并集（Smooth Union）等算法，均可以在上述IQ的文章中找到。</p>
<hr>
<h3 id="SDF的其他应用"><a href="#SDF的其他应用" class="headerlink" title="SDF的其他应用"></a>SDF的其他应用</h3><p>了解SDF之后，我们可以在raymarching的时候做一些trick来实现一些有趣的效果，如我们对raymarching时传入的位置坐标做<strong>周期性的取模</strong>，遍可以实现无限循环的模型效果，如下图所示，我将距离函数$f(x)=x$转换为周期为a的函数，即可以对空间内每一个$a^3$的立方体进行SDF计算，从而得到无限的空间。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102163917.png" alt=""><br>如下图是对一个球体和立方体求差集后对齐周期性采样的结果<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/EndlessEx1.gif" alt=""><br>可以看到raymarching通过对SDF的简单计算便可以得到强大的结果。这里我是参考于<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ABb4opx08o8&amp;t=3s">&#x1F4CC;油管上对ray marching的一个详细教程</a>。</p>
<hr>
<h2 id="着色（Shading）"><a href="#着色（Shading）" class="headerlink" title="着色（Shading）"></a>着色（Shading）</h2><p>在使用射线以及SDF处理完<strong>几何信息</strong>之后，我们需要对得到的几何信息（对应在计算机屏幕上则为像素）进行<strong>着色</strong>，这里我将使用最基础的光照模型来进行raymarching下着色的说明。</p>
<h3 id="计算法线"><a href="#计算法线" class="headerlink" title="计算法线"></a>计算法线</h3><p>在基础光照模型中我们对光的计算离不开几何体的<strong>表面法线</strong>，在一般的渲染流程中，法线信息通常来源于模型的<strong>顶点信息</strong>或是<strong>法线贴图</strong>，在raymarching中，我们没有这两个信息，因此需要自己计算表面法线。<br>这里我们通过求<strong>梯度</strong>的公式来获得表面法线，即计算点$P(x,y,z)$在三个坐标轴方向上<strong>SDF函数值</strong>的偏导，来得到该点的法线方向。<br>$n = normalize(\nabla f(p))$<br>$\nabla f(p) =\begin{Bmatrix} \frac{df(p)}{dx}, \frac{df(p)}{dy}, \frac{df(p)}{dz} \end{Bmatrix}$<br>$\frac{df(p)}{dx} \simeq \frac{f(p + (h, 0, 0)) - f(p)}{h}$</p>
<p>如上所示，我们便完成了raymarching某交点（屏幕像素）的法线计算，用代码简单计算如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float2 tinyVal = <span class="built_in">float2</span>(<span class="number">0.00001</span>, <span class="number">0.0</span>);</span><br><span class="line">float3 normal = <span class="built_in">float3</span></span><br><span class="line">(</span><br><span class="line">	<span class="built_in">GetDistance</span>(pos + tinyVal.xyy) - <span class="built_in">GetDistance</span>(pos),</span><br><span class="line">	<span class="built_in">GetDistance</span>(pos + tinyVal.yxy) - <span class="built_in">GetDistance</span>(pos),</span><br><span class="line">	<span class="built_in">GetDistance</span>(pos + tinyVal.yyx) - <span class="built_in">GetDistance</span>(pos)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">normalize</span>(normal);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Lambert漫反射模型"><a href="#Lambert漫反射模型" class="headerlink" title="Lambert漫反射模型"></a>Lambert漫反射模型</h3><p>这里我们使用基础的<strong>Lambert模型</strong>来计算漫反射，以平行光为例，我们认为从<strong>光源</strong>出射的光线在单位面积上的<strong>辐照度</strong>来表示，那么当光线是斜着入射到物体表面时，相同辐照度反应在物体表面的面积就增大了，因此亮度也会相应地降低，这里我们可以用<strong>表面法线与光线入射方向的点积</strong>来计算这个差异，如下图所示。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102180250.png" alt=""><br>这里需要注意的是，对于模型背面的点，其法线与入射光方向的点积结果为<strong>负数</strong>，在图形学中负数对于颜色的影响与0一样（均为黑色），但是为了让后续的计算不出现问题，我们对结果取<strong>非负处理</strong>，因此最终漫反射颜色计算公式为<br>$C_{diffuse} = max(0, dot(normal, lightDir)) * C_{light} * I_{light}$<br>其中C为颜色，I为入射光辐照度。</p>
<h4 id="半Lambert漫反射模型"><a href="#半Lambert漫反射模型" class="headerlink" title="半Lambert漫反射模型"></a>半Lambert漫反射模型</h4><p>从上述公式可以看出，Lambert漫反射模型会让模型<strong>背向光源</strong>的一半完全呈现黑色（因为点积为负），因此出现了<strong>半Lambert模型</strong>，其计算也很简单，即把上述公式中的max()部分改变为：<br>$dot(normal, lightDir) * 0.5 + 0.5$<br>即<br>$C_{diffuse} = (dot(normal, lightDir) * 0.5 + 0.5) * C_{light} * I_{light}$<br>我们将两者的函数图像及实际效果作比较，可以看出半Lambert模型的结果会比前者拥有更多层次。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102190412.png" alt=""></p>
<hr>
<h3 id="Blinn-Phong高光模型"><a href="#Blinn-Phong高光模型" class="headerlink" title="Blinn-Phong高光模型"></a>Blinn-Phong高光模型</h3><p>对于一些<strong>表面光滑</strong>的物体，除了漫反射，我们还需要高光反射，光线能够大部分经过法线而反射到我们的<strong>观察点（如相机）</strong>。<br>最基础的高光模型是<strong>Phong式</strong>算法，我们将<strong>入射光方向经过法线反射的方向</strong>与<strong>观察方向</strong>做点积，这样越接近恰好反射到观察点的表面位置，高光越强，如下图所示：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103005323.png" alt=""><br>但是这个方法当观察方向与入射光方向在<strong>法线同侧</strong>时，反射方向与观察方向的夹角将会<strong>大于90°</strong>，导致点积为负数，这样当相机转到某一个角度时，会出现高光突然消失的情况，这是我们不希望看到的，于是便有了<strong>Blinn-Phong高光模型</strong>。<br>在Phong式模型的基础上，我们计算了中间向量H，它是入射光方向与视线方向的平均，我们用<strong>向量H</strong>与<strong>法线N</strong>求点积，这样就保证了H和N的夹角永远不会大于90°，如下图所示：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103005019.png" alt=""></p>
<p>如果直接求得点积，那么cos函数的变化会太过平滑，导致我们不希望看到的<strong>高光面积过于大</strong>的情况，因此我们引入一个新的变量shininess，来对点积结果进行<strong>次幂</strong>操作，来缩小高光的面积。因此最终，我们能够得到高光的计算公式；<br>$C_{specular} = pow(max(0, dot(H, N)), shininess) · C_{light} · I_{light}$<br>计算完高光后，我们可以得到如下的效果：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103010652.png" alt=""><br>可以看到随着角度、和shininess的变化，高光的强度和范围都会发生相应的变化。</p>
<hr>
<h4 id="结果合并"><a href="#结果合并" class="headerlink" title="结果合并"></a>结果合并</h4><p>在得到了<strong>漫反射（Diffuse）</strong>和<strong>高光（Specular）</strong>之后，我们便可以将他们相加后乘以物体的固有色，得到基础光照的最终结果$C_{final}=C_{origin}·C_{light}·I_{light}·(P_{diffuse} + P_{specular})$</p>
<p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103132335.png" alt=""></p>
<hr>
<h3 id="深度缓存与遮挡"><a href="#深度缓存与遮挡" class="headerlink" title="深度缓存与遮挡"></a>深度缓存与遮挡</h3><p>到目前为止，我们已经得到了屏幕每个像素的颜色，但是这里仅仅是获得了<strong>通过raymarching渲染得到的像素颜色</strong>，如果场景中还存在其余渲染结果，如最普遍的Forwardbase Rendering或Deferred Rendering等，则我们会得到不正确的结果，如下图所示<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/DepthIntro_1.gif" alt=""><br>我在场景中放置了一个立方体，该立方体是用<strong>前向渲染（Forwardbase Rendering）</strong>完成渲染的，但是当旋转相机的时候，本应该挡住球体的立方体，被渲染在了球体之后，看起来就变得十分怪异。<br>为了解决这个问题，我们需要用到深度缓存，在进行画面渲染的时候，为了保证越靠近镜头的物体被渲染在越前面，我们需要用到一些算法，譬如<strong>画家算法（已经不再使用）</strong>或者<strong>深度缓存（Depth Buffer）</strong>。<br>深度缓存为屏幕上的每一个像素都存储了一个<strong>深度值</strong>，该深度值的取值为[0, 1]，我们可以将一个场景的深度缓存中的值输出为颜色，如下图，可以看到，越<strong>靠近相机</strong>的颜色越接近黑色，这是因为从近到远，深度值是从0到1。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103134925.png" alt=""><br>我们将该深度值乘以<strong>相机视椎体的远平面</strong>，便可以得到[0, Far]取值的深度值，也就是说，我们得到了屏幕上<strong>每一个像素最接近相机的物体的距离</strong>，于是我们可以将该距离与raymarching的结果相比，便可以得到<strong>遮挡关系</strong>，如下图是加入了深度值比较后的正确结果<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/DepthIntro2.gif" alt=""><br>在代码实现上看，我们仅需把前文中RayMarching函数的判断部分增加上与深度值的比较即可，如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(total &gt; MAX_DISTANCE || total &gt;= depth)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="硬阴影与软阴影"><a href="#硬阴影与软阴影" class="headerlink" title="硬阴影与软阴影"></a>硬阴影与软阴影</h3><p>到目前，我们已经解决了排序问题和着色问题，现在我们创建几个SDF函数，分别是由两个球体和一个立方体交并运算得到的几何体，和一个平面，我们将他们求并集，得到的结果如下：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103142613.png" alt=""><br>可以看到，虽然我将几何体放置在了平面的正上方，但是看上去仍然像是“漂浮”在平面之上，其中一个重要原因是这里缺少了<strong>投影</strong>。对于前向渲染等，展示投影的方式有譬如<strong>Shadow Map</strong>等。但是<strong>在Ray Marching中，我们可以更加方便地得到投影</strong>。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211102150236.png" alt=""><br>再次使用文章开头的这张图，但是这次我们关注的是图中右边蓝色标注的<strong>Shadow Ray</strong>，在raymarching中，我们如果想得到一个<strong>像素是否处于阴影中</strong>，我们只需要从该处，向<strong>光源方向再做一次Ray Marching</strong>，如果射线与物体相交，则说明该像素处于阴影中，反之则不在阴影中，代码表示如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">HardShadow</span><span class="params">(float3 ro, float3 rd, <span class="keyword">float</span> maxDis, <span class="keyword">float</span> minDis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">float</span> t = minDis; t &lt; maxDis;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">float</span> dis = <span class="built_in">GetDistance</span>(ro + rd * t);</span><br><span class="line">		<span class="comment">// Hit something</span></span><br><span class="line">		<span class="keyword">if</span>(dis &lt; minDis * <span class="number">0.5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		t += dis;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里我们传入的ro（Ray Origin），需要加上一个微小的偏移，一般是<strong>沿法线方向偏移一个极小的值</strong>，因为直接代入某点的话，该点已经处在某个几何体上，其GetDistance的结果就为0。<br>现在我们拥有了基础的阴影计算结果，把它代入到我们的着色函数中，可以得到如下图结果：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103143637.png" alt=""><br>从结果中可以看出，阴影正确地投影在了地面以及几何体自身。但是这个阴影的结果有些锋利，其<strong>边缘非常硬（Hard Shadow）</strong>，为了得到一个更柔化的边缘，我们可以在上述函数的基础上做出一些修改，来得到<strong>软阴影（Soft Shadow）</strong>。<br>在raymarching中获得软阴影的思想是，对于<strong>没有被遮挡的像素</strong>，我们找到<strong>步进过程中，最靠近几何体的采样点，占总采样距离的比例的最小值</strong>。这样，稍偏离硬阴影的部分，其软阴影也最强。原理如下图<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103145104.png" alt=""><br>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">SoftShadow</span><span class="params">(float3 ro, float3 rd, <span class="keyword">float</span> maxDis, <span class="keyword">float</span> minDis, <span class="keyword">float</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> result = <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">float</span> t = minDis; t &lt; maxDis;)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">float</span> dis = <span class="built_in">GetDistance</span>(ro + rd * t);</span><br><span class="line">        <span class="comment">// Hit something</span></span><br><span class="line">        <span class="keyword">if</span>(dis &lt; minDis * <span class="number">0.5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">min</span>(result, k * dis / t);</span><br><span class="line">        t += dis;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中k为调整参数，k越小，result值越小，软阴影效果越强。<br>通过调整k参数，我们可以得到软阴影的效果如下图<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/RM_SoftShadow.gif" alt=""></p>
<hr>
<h3 id="AO环境光遮蔽"><a href="#AO环境光遮蔽" class="headerlink" title="AO环境光遮蔽"></a>AO环境光遮蔽</h3><p>有了阴影，我们的几何体看上去更像是被<strong>放在了地面上</strong>，但是我们还可以做到更多，譬如看如下图的位置，在现实世界中，如墙角等垂直的平面上，都会比周围的亮度更低，而我们现在的结果还没有展现这一点。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103151001.png" alt=""><br>这里我们可以使用<strong>环境光遮蔽（Ambient Occlusion）</strong>技术来实现这一点。<br>AO的定义如下：AO是来描绘<strong>物体和物体相交或靠近</strong>的时候<strong>遮挡周围漫反射光线</strong>的效果，可以解决或改善漏光、飘和阴影不实等问题，解决或改善场景中<strong>缝隙、褶皱与墙角、角线以及细小物体</strong>等的表现不清晰问题，综合改善细节尤其是<strong>暗部阴影</strong>，增强空间的层次感、真实感，同时加强和改善画面明暗对比，增强画面的艺术性。<br>如下图，AO让老人脸上的皱纹等区域的亮度减少，显得层次感比原图更加丰富。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103151322.png" alt=""></p>
<p>本文中我们只讨论RayMarching下的AO实现，我们<strong>沿着法线方向一点点步进</strong>，每个点使用GetDistance采样一次，并把结果和<strong>步进总距离</strong>作比较，可以想象，当某像素的周围有其它遮挡物时，GetDistance的结果会比步进距离小，而当某像素的周围一片空旷时，GetDistance的结果和步进距离是相同的。我们可以用代码实现如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">AmbientOcclusion</span><span class="params">(float3 pos, float3 normal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> ao = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">float</span> dist = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= _AoIteration; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist = _AoStep * i;</span><br><span class="line">		ao += <span class="built_in">max</span>(<span class="number">0.0</span>, (dist - <span class="built_in">GetDistance</span>(pos + normal * dist)) / dist);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> - ao * _AoIntensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我将AO的计算结果直接作为颜色输出，得到如下结果：<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211103152255.png" alt=""><br>可以看见，缝隙、细小处的阴影也被完整表达了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们把raymarching和光照等结果都处理完毕了，我们把每一步的结果拆解表达如下。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/RmResult.jpg" alt=""><br>Ray Marching在实时渲染的领域中常常被用来处理<strong>体积相关</strong>的画面效果，如<strong>体积光（Volumetric Light）</strong>，<strong>云</strong>等。<br>有关体积光和云等的效果的实现将用单独的文章来介绍。<br>此外，在ShaderToy上还有许多出色的艺术家使用RayMarching来实现惊人的几何和光照等效果，如<a target="_blank" rel="noopener" href="https://www.shadertoy.com/view/ld3Gz2">&#x1F4CC;IQ大佬用RM实现的实时渲染蜗牛</a>，都是非常优秀的效果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/26/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="名が無い生身">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="四次元">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/26/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%89/" class="post-title-link" itemprop="url">Shader入门精要读书笔记（前置知识）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-26 17:12:30" itemprop="dateCreated datePublished" datetime="2021-09-26T17:12:30+09:00">2021-09-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-11-14 14:27:21" itemprop="dateModified" datetime="2021-11-14T14:27:21+09:00">2021-11-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E5%90%91/" itemprop="url" rel="index"><span itemprop="name">技术向</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Shader入门精要读书笔记——前置知识"><a href="#Shader入门精要读书笔记——前置知识" class="headerlink" title="Shader入门精要读书笔记——前置知识"></a>Shader入门精要读书笔记——前置知识</h1><hr>
<h2 id="数学篇"><a href="#数学篇" class="headerlink" title="数学篇"></a>数学篇</h2><ul>
<li>二/三维笛卡尔坐标系</li>
<li>左手坐标系和右手坐标系</li>
<li>点和矢量</li>
<li>矩阵、矩阵运算、特殊矩阵</li>
</ul>
<hr>
<h2 id="矩阵的几何意义：变换"><a href="#矩阵的几何意义：变换" class="headerlink" title="矩阵的几何意义：变换"></a>矩阵的几何意义：变换</h2><p>在游戏开发中，三维（二维）物体的变换即是<strong>矩阵的可视化</strong>方式。这里的变化一般包括：平移、旋转和缩放。例如Unity中的Transform即包括了这三个属性。</p>
<blockquote>
<p>什么是变换？<br>变换指将数据（位置、方向、甚至颜色等）通过计算进行转换的过程。</p>
</blockquote>
<p>变换中的一个重要类型是<strong>线性变换</strong>，线性变换指满足以下两个条件的变换：<br>$f(x)+f(y)=f(x+y)\quad(1)$<br>$kf(x)=f(kx)\quad(2)$<br>上面提到的旋转和缩放就是线性变换。<br>值得注意的是，<strong>平移</strong>并非线性变换，如我们从点(1, 1, 1)进行2次(1, 2, 3)的平移，代入上(1)式，得<br>$f(1,2,3)+f(1,2,3)=(4,6,8)$<br>$f((1,2,3)+(1,2,3))=(3,5,7)$<br>可见两式结果并不相等，因此我们<strong>不能</strong>仅使用3x3的矩阵来表示上面的所有变换。</p>
<hr>
<h3 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h3><p>为了表示所有变换，我们将3x3的矩阵扩展到4x4的矩阵，相应地，<strong>点</strong>和<strong>方向</strong>的向量也需要从三维矢量扩展到四维矢量，扩展后的坐标便称为<strong>齐次坐标</strong>。<br>我们把点和方向扩展到四维向量时，按以下方式填充它们的第四维元素w（这么填充的原因在后续变换时可以看到）：<br>$点向量 P(x,y,z)—-&gt;P(x,y,z,1)$<br>$方向向量 D(x,y,z)—-&gt;D(x,y,z,0)$</p>
<hr>
<h4 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h4><p>所有的变换矩阵都可以表示如下<br>$<br>\left[<br>\begin{matrix}<br>M_{3×3} &amp; t_{3×1} \\<br>0_{1×3} &amp; 1 \\<br>\end{matrix}<br>\right]<br>$<br>其中左上角的M用作缩放和旋转，右上角的t用作平移。</p>
<hr>
<h4 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h4><p>平移矩阵如下，左右分别为对<strong>点</strong>和<strong>向量</strong>的计算结果<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211015161235.png" alt=""><br>可见平移矩阵对点产生了正确的偏移，而不会对方向产生影响。<br>平移矩阵的逆矩阵即右上的t部分取符号相反。<br>平移矩阵并非正交矩阵。</p>
<hr>
<h4 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h4><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211015161747.png" alt=""><br>缩放矩阵对点和方向均会产生影响。<br>缩放矩阵的逆矩阵即每项取倒数。<br>缩放矩阵并非正交矩阵。<br>缩放系数 $k_1=k_2=k_3$ 的称为<strong>统一缩放(uniform scale)</strong>，否则称为<strong>非统一缩放(nonuniform scale)</strong>。</p>
<ul>
<li>注意，非统一缩放会改变与模型相关的<strong>角度</strong>，如后续提到的<strong>法线变换</strong>。</li>
</ul>
<hr>
<h4 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h4><p><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211015162714.png" alt=""><br>旋转矩阵分别根据物体绕的坐标轴，可以分为3部分。</p>
<hr>
<h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p>不同的变换可以通过矩阵乘法来进行组合，如<br>$<br>P_{new}=M_{translation}M_{rotation}M_{scale\theta}P_{old}<br>$<br>这里我们如上述图中使用的都是<strong>列矩阵</strong>，阅读顺序为<strong>从右到左</strong>，因此这里变换的顺序为先缩放，再旋转，再平移，这是符合直觉的（如果先平移，再缩放，则缩放会把平移的位移进一步缩放）。<br>这里的<strong>矩阵顺序</strong>必须严格按照变换顺序来计算，其根本原因是矩阵乘法<strong>不满足交换律</strong>。</p>
<hr>
<h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><p>在游戏开发中，我们需要用到很多不同的坐标系。</p>
<blockquote>
<p>为什么要用那么多坐标系？<br>因为不同场合使用不同的坐标系方便。所有坐标系理论上都是平等的，只有方便/麻烦之分，而没有对错之分。</p>
</blockquote>
<h3 id="坐标空间的转换"><a href="#坐标空间的转换" class="headerlink" title="坐标空间的转换"></a>坐标空间的转换</h3><p>已知子坐标空间C的三个坐标轴在父坐标空间P下的表示$x_c,y_c,z_c$，以及原点位置$O_c$，当已知一个子坐标空间下的点$A(a,b,c)$，我们可以得到<br>$A_p=O_c+ax_c+by_c+cz_c$<br>$A_p=(x_{oc},y_{oc},z_{oc})+\left[<br>\begin{matrix}<br>x_{xc} &amp; x_{yc} &amp; x_{zc} \\<br>y_{xc} &amp; y_{yc} &amp; y_{zc} \\<br>z_{xc} &amp; z_{yc} &amp; z_{zc} \\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>a \\<br>b \\<br>c \\<br>\end{matrix}<br>\right]$<br>为了去掉这个加号（<strong>即平移</strong>），我们将其扩展到<strong>齐次坐标</strong>下<br>$A_p=(x_{oc},y_{oc},z_{oc}, 1)+\left[<br>\begin{matrix}<br>x_{xc} &amp; x_{yc} &amp; x_{zc} &amp; 0 \\<br>y_{xc} &amp; y_{yc} &amp; y_{zc} &amp; 0 \\<br>z_{xc} &amp; z_{yc} &amp; z_{zc} &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>a \\<br>b \\<br>c \\<br>1 \\<br>\end{matrix}<br>\right]$<br>$=<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 &amp; x_{oc} \\<br>0 &amp; 1 &amp; 0 &amp; y_{oc} \\<br>0 &amp; 0 &amp; 1 &amp; z_{oc} \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>x_{xc} &amp; x_{yc} &amp; x_{zc} &amp; 0 \\<br>y_{xc} &amp; y_{yc} &amp; y_{zc} &amp; 0 \\<br>z_{xc} &amp; z_{yc} &amp; z_{zc} &amp; 0 \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>a \\<br>b \\<br>c \\<br>1 \\<br>\end{matrix}<br>\right]$<br>$=<br>\left[<br>\begin{matrix}<br>x_{xc} &amp; x_{yc} &amp; x_{zc} &amp; x_{oc} \\<br>y_{xc} &amp; y_{yc} &amp; y_{zc} &amp; y_{oc} \\<br>z_{xc} &amp; z_{yc} &amp; z_{zc} &amp; z_{oc} \\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>a \\<br>b \\<br>c \\<br>1 \\<br>\end{matrix}<br>\right]$<br>$=M_{c-&gt;p}P_A$<br>于是我们便得到了从坐标空间C转换到坐标空间P的变换矩阵$M_{c-&gt;p}$。<br>现在我们只取左上角的3x3矩阵作为讨论，来求从P到C的变换矩阵。<br>因为坐标轴均为单位向量，所以$M_{c-&gt;p}$是一个<strong>正交矩阵</strong>，其<strong>逆矩阵</strong>等于其<strong>转置矩阵</strong>。<br>所以我们有<br>$M_{p-&gt;c}=M^{-1}_{c-&gt;p}=M^T_{c-&gt;p}$<br>$=\left[<br>\begin{matrix}<br>x_{xc} &amp; y_{xc} &amp; z_{xc} \\<br>x_{yc} &amp; y_{yc} &amp; z_{yc} \\<br>x_{zc} &amp; y_{zc} &amp; z_{zc} \\<br>\end{matrix}<br>\right]$<br>这样我们就求出了从P空间转换到C空间的变换矩阵。</p>
<hr>
<h3 id="常用的坐标空间"><a href="#常用的坐标空间" class="headerlink" title="常用的坐标空间"></a>常用的坐标空间</h3><blockquote>
<p>模型空间（Model Space）</p>
</blockquote>
<p>我们拿到的模型（网格数据Mesh），其中的顶点均是以模型坐标系存储的。<br><strong>模型空间</strong>有时也被称作<strong>对象空间（Object Space）</strong>或<strong>局部空间（Local Space）</strong>。</p>
<hr>
<h4 id="世界空间（World-Space）"><a href="#世界空间（World-Space）" class="headerlink" title="世界空间（World Space）"></a>世界空间（World Space）</h4><p>世界空间是我们处理计算机图像时接触到的最大的坐标系，且其只有一个。<br>从模型空间变换到世界空间，本质上就是对每个顶点进行<strong>平移，旋转，缩放</strong>的过程。<br>其变换矩阵如下<br>$M_{model}=M_{translation}M_{rotation}M_{scale\theta}$<br>所以我们有$P_{world}=M_{model}P_{model}$</p>
<hr>
<h4 id="观察空间（View-Space）"><a href="#观察空间（View-Space）" class="headerlink" title="观察空间（View Space）"></a>观察空间（View Space）</h4><p>观察空间即摄像机空间（Camera Space），是以摄像机（也就是观察者）为原点的空间坐标系。</p>
<ul>
<li>如何得到顶点在观察空间的坐标？</li>
</ul>
<ol>
<li>计算观察空间的3个坐标轴在世界空间下的坐标，运用前述方法计算出世界空间到观察空间的变换矩阵。</li>
<li>想象<strong>相机</strong>在世界空间下的变换过程，即先<strong>旋转</strong>后<strong>平移</strong>，我们用逆变换将其回到世界空间原点，就相当于把所有世界空间中的顶点变换到观察空间下。</li>
</ol>
<p><strong>显然，两者得到的结果是完全相同的</strong></p>
<hr>
<h4 id="裁剪空间（Clip-Space）"><a href="#裁剪空间（Clip-Space）" class="headerlink" title="裁剪空间（Clip Space）"></a>裁剪空间（Clip Space）</h4><p>裁剪空间的目的是对顶点进行裁剪，以此来判断那些顶点需要被显示，那些顶点因为在屏幕外而需要被<strong>裁剪</strong>。<br>这里的”屏幕外“由视锥体决定，最常用的是<strong>透视投影</strong>和<strong>正交投影</strong>，来定义2种不同的视椎体，效果如下图。<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020211026.png" alt=""></p>
<ul>
<li>这个矩阵有什么用呢？<br>我们用这两种投影矩阵变换<strong>世界空间</strong>下的坐标后，将会得到一组新的$(x, y, z, w)$坐标，这组坐标将会让我们在<strong>裁剪顶点时计算更方便</strong>。正常地裁剪，我们需要判断一个顶点的坐标是否被视椎体的6个平面包围，这个计算的消耗太大；而变换后，我们只需要用x，y，z分别与第四个分量w作比较即可。 </li>
</ul>
<p>如下图是<strong>透视矩阵</strong>以及变换后的顶点坐标<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020213154.png" alt=""><br>如下图是<strong>透视矩阵</strong>变换后的关键顶点的坐标<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020211756.png" alt=""><br>如下图是<strong>正交矩阵</strong>以及变换后的顶点坐标<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020213329.png" alt=""><br>如下图是<strong>正交矩阵</strong>变换后的关键顶点的坐标<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020213711.png" alt=""></p>
<hr>
<h4 id="屏幕空间（Screen-Space）"><a href="#屏幕空间（Screen-Space）" class="headerlink" title="屏幕空间（Screen Space）"></a>屏幕空间（Screen Space）</h4><p>屏幕空间坐标，即<strong>二维</strong>坐标，是显示器上的像素位置，其范围是$(0, 0)—(Screen_{Width}, Screen_{Height})$。<br>经过上一步的投影矩阵变换，现在我们计算屏幕空间坐标就变得非常简单了。<br>将上一步的x，y分别除以w分量后，我们得到了2个范围在(-1,1)的分量（注：OpenGL中这个值是(-1, 1)，而DirectX中这个值的范围是(0, 1)），我们将这个范围<strong>remap到屏幕分辨率</strong>即可。</p>
<p>值得注意的是，这里的z分量除以w后，一般情况下都被用作了<strong>深度缓冲</strong>，这个值的范围是(0, 1)。深度缓冲将被用作深度检测等地方。</p>
<ul>
<li><strong>重要</strong>的是，注意到上述<strong>透视矩阵</strong>变换后的顶点坐标，我们将z除以w分量后可以得到：<br>$\frac{Far+Near}{Far-Near} + \frac{2*Near*Far}{z(Far-Near)}$<br>简化换元后为<br>$k\frac{1}{z}+C$<br>可以看到，经过透视矩阵转换后，<strong>Z的值与转换前并非线性关系</strong>，即<strong>深度值非线性的</strong>。<br>此外，<strong>正交矩阵</strong>并不存在这个问题。</li>
</ul>
<p>如下图，为变换后的<strong>深度值随原Z坐标</strong>变化的曲线<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020225300.png" alt=""></p>
<hr>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在一系列变换之后，<strong>片元（fragment）</strong>还需要通过一系列测试，如<strong>深度测试</strong>，<strong>模板测试</strong>等之后，才可以正式将颜色着色在该像素上。<br>此外，在着色的时候，也有着许多不同的混合方式，如<strong>不透明</strong>物体会将自身颜色直接替换掉当前像素的<strong>颜色缓冲</strong>，并更新<strong>深度值</strong>；而<strong>透明</strong>物体会将自身颜色与<strong>颜色缓冲</strong>中的颜色值进行<strong>混合</strong>，这里的混合又有多重计算方式，如常见的计算方式是<br>$Color_{Final} = Alpha * Color_{Fragment} + (1 - Alpha) * Color_{Origin}$</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里整理一下上述提到的渲染管线的整体流程如下<br><img src="https://raw.githubusercontent.com/zyz120/Z_FigureBed/main/20211020224117.png" alt=""></p>
<p>经过上述的步骤，模型中的顶点就正式被渲染到了显示器的像素上。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">名が無い生身</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
